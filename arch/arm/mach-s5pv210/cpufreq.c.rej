--- arch/arm/mach-s5pv210/cpufreq.c
+++ arch/arm/mach-s5pv210/cpufreq.c
@@ -143,6 +143,17 @@
 	{7, 7, 0, 0, 7, 0, 9, 0, 7, 0, 0},
 };
 
+#ifdef CONFIG_LIVE_OC
+extern void cpufreq_stats_reset(void);
+
+static int oc_value = 100;
+
+static unsigned long sleep_freq;
+static unsigned long original_fclk[] = {1000000, 800000, 800000, 800000, 800000};
+
+static u32 apll_values[sizeof(original_fclk) / sizeof(unsigned long)];
+#endif
+
 /*
  * This function set DRAM refresh counter
  * accoriding to operating frequency of DRAM
@@ -166,7 +177,11 @@
 	/* Find current DRAM frequency */
 	tmp = s5pv210_dram_conf[ch].freq;
 
+#ifdef CONFIG_LIVE_OC
+	do_div(tmp, (freq * oc_value) / 100);
+#else
 	do_div(tmp, freq);
+#endif
 
 	tmp1 = s5pv210_dram_conf[ch].refresh;
 
@@ -379,10 +394,14 @@
 		 * 6-1. Set PMS values
 		 * 6-2. Wait untile the PLL is locked
 		 */
+#ifdef CONFIG_LIVE_OC
+		__raw_writel(apll_values[index], S5P_APLL_CON);
+#else
 		if (index == L0)
 			__raw_writel(APLL_VAL_1000, S5P_APLL_CON);
 		else
 			__raw_writel(APLL_VAL_800, S5P_APLL_CON);
+#endif
 
 		do {
 			reg = __raw_readl(S5P_APLL_CON);
@@ -510,6 +529,105 @@
 	return val >> 8;
 }
 
+#ifdef CONFIG_LIVE_OC
+static int find_divider(int freq)
+{
+    int i, divider;
+
+    divider = 24;
+
+    if (freq % 3 == 0) {
+	freq /= 3;
+	divider /= 3;
+    }
+ 
+    for (i = 0; i < 3; i++) {
+	if (freq % 2 == 0) {
+	    freq /= 2;
+	    divider /= 2;
+	}
+    }
+
+    return divider;
+}
+
+static void liveoc_init(void)
+{
+    int i, index, divider;
+
+    unsigned long fclk;
+
+    i = 0;
+
+    while (s5pv210_freq_table[i].frequency != CPUFREQ_TABLE_END) {
+	index = s5pv210_freq_table[i].index;
+
+	fclk = original_fclk[index] / 1000;
+
+	divider = find_divider(fclk);
+
+	apll_values[index] = ((1 << 31) | (((fclk * divider) / 24) << 16) | (divider << 8) | (1));
+
+	i++;
+    }
+
+    sleep_freq = SLEEP_FREQ;
+
+    return;
+}
+
+void liveoc_update(unsigned int oc_value)
+{
+    int i, index, index_min = L0, index_max = L0, divider;
+
+    unsigned long fclk;
+
+    struct cpufreq_policy * policy = cpufreq_cpu_get(0);
+
+    mutex_lock(&set_freq_lock);
+
+    i = 0;
+
+    while (s5pv210_freq_table[i].frequency != CPUFREQ_TABLE_END) {
+
+	index = s5pv210_freq_table[i].index;
+	
+	if (s5pv210_freq_table[i].frequency == policy->user_policy.min)
+	    index_min = index;
+
+	if (s5pv210_freq_table[i].frequency == policy->user_policy.max)
+	    index_max = index;
+
+	fclk = (original_fclk[index] * oc_value) / 100;
+
+	s5pv210_freq_table[i].frequency = fclk / (clkdiv_val[index][0] + 1);
+
+	if (original_fclk[index] / (clkdiv_val[index][0] + 1) == SLEEP_FREQ)
+	    sleep_freq = s5pv210_freq_table[i].frequency;
+
+	fclk /= 1000;
+
+	divider = find_divider(fclk);
+
+	apll_values[index] = ((1 << 31) | (((fclk * divider) / 24) << 16) | (divider << 8) | (1));
+
+	i++;
+    }
+
+    cpufreq_frequency_table_cpuinfo(policy, s5pv210_freq_table);
+
+    policy->user_policy.min = s5pv210_freq_table[index_min].frequency;
+    policy->user_policy.max = s5pv210_freq_table[index_max].frequency;  
+
+    mutex_unlock(&set_freq_lock);
+
+    cpufreq_stats_reset();
+
+    return;
+}
+EXPORT_SYMBOL(liveoc_update);
+#endif
+
 static int __init s5pv210_cpu_init(struct cpufreq_policy *policy)
 {
 	unsigned long mem_type;
@@ -558,6 +676,10 @@
 
 	policy->cpuinfo.transition_latency = 40000;
 
+#ifdef CONFIG_LIVE_OC
+	liveoc_init();
+#endif
+
 	return cpufreq_frequency_table_cpuinfo(policy, s5pv210_freq_table);
 }
 
@@ -568,15 +690,25 @@
 
 	switch (event) {
 	case PM_SUSPEND_PREPARE:
+#ifdef CONFIG_LIVE_OC
+		ret = cpufreq_driver_target(cpufreq_cpu_get(0), sleep_freq,
+				DISABLE_FURTHER_CPUFREQ);
+#else
 		ret = cpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ,
 				DISABLE_FURTHER_CPUFREQ);
+#endif
 		if (ret < 0)
 			return NOTIFY_BAD;
 		return NOTIFY_OK;
 	case PM_POST_RESTORE:
 	case PM_POST_SUSPEND:
+#ifdef CONFIG_LIVE_OC
+		cpufreq_driver_target(cpufreq_cpu_get(0), sleep_freq,
+				ENABLE_FURTHER_CPUFREQ);
+#else
 		cpufreq_driver_target(cpufreq_cpu_get(0), SLEEP_FREQ,
 				ENABLE_FURTHER_CPUFREQ);
+#endif
 		return NOTIFY_OK;
 	}
 	return NOTIFY_DONE;
